# -*- coding: utf-8 -*-
"""Algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12T7gm0fDlNRkBwxnyGKaHmE4Nuq20Jl1
"""

!pip install biopython

"""***`COMPUTING FREQUENCIES`***"""

###COMPUTING FREQUENCIES 3
def SYMBOLTONUMBER(c):
    if c=='A':
        return 0
    if c=='C':
        return 1
    if c=='G':
        return 2
    if c=='T':
        return 3
def PATTERNTONUMBER(pattern):
    if len(pattern)==0:
        return 0
    symbol=pattern[-1]
    prefix=pattern[0:len(pattern)-1]
    return 4*PATTERNTONUMBER(prefix)+SYMBOLTONUMBER(symbol)
    
def COMPUTINGFREQUENCIES(text, k):
    limit=(4**k)-1
    dic={};
    for i in range(limit):
        dic[i]=int(0)
    size=len(text)-k
    for i in range(size):
        pattern=text[i:i+k]
        print("Pattern=",pattern)
        j=PATTERNTONUMBER(pattern)
        dic[j]=dic[j]+1
    return dic
print(COMPUTINGFREQUENCIES("ACGTCCGT",4))

"""***`Neighbor Finding`***"""

###Neighbor Finding 8
def HAMMINGDISTANCE(suffix,text):
    cnt=0
    for i in range(len(text)):
        if(suffix[i]!=text[i]):
            cnt=cnt+1
    return cnt
 
def NEIGHBOR(pattern,d):
    if d==0:
        return {pattern} #set containing only pattern
    if len(pattern)==1:
        return {"A","C","G","T"}
    Neighborhood=set()
    SuffixNeighbors=NEIGHBOR(pattern[1:len(pattern)],d)
 
    neucleotide={"A","C","G","T"}
 
    for text in SuffixNeighbors:
        suffix=pattern[1:len(pattern)]
        if HAMMINGDISTANCE(suffix,text)<d:
            for x in neucleotide:
                Neighborhood.add(x+text)
        else:
            Neighborhood.add(pattern[0]+text)
 
    return Neighborhood
 
print(NEIGHBOR("ACT",1))

"""***`Number to Pattern`***"""

### Number to Pattern 5
def getVal(k):
    if k==0:
        return 'A'
    if k==1:
        return 'C'
    if k==2:
        return 'G'
    return 'T'
def NUMBERTOPATTERN(index, k):
    initial=index
    str=""
    while (k>0):
        rem=int(initial%4)
        str=str+getVal(rem)
        initial=initial/4
        k=k-1
    str=str[::-1]
    return str
print(NUMBERTOPATTERN(9904,7))

"""***`Pattern to Number`***"""

### Pattern to Number 4
def SYMBOLTONUMBER(c):
    if c=='A':
        return 0
    if c=='C':
        return 1
    if c=='G':
        return 2
    if c=='T':
        return 3
def PATTERNTONUMBER(pattern):
    if len(pattern)==0:
        return 0
    symbol=pattern[-1]
    prefix=pattern[0:len(pattern)-1]
    return 4*PATTERNTONUMBER(prefix)+SYMBOLTONUMBER(symbol)
print(PATTERNTONUMBER("GCGGTAA"))

"""***`HAMMING DISTANCE`***"""

### Hamming Distance 2
def HAMMINGDISTANCE(suffix,text):
    cnt=0
    for i in range(len(text)):
        if(suffix[i]!=text[i]):
            cnt=cnt+1
    return cnt
print(HAMMINGDISTANCE("GCGGTAA","GCTGTAC"))

"""***`CLUMP FINDING`***"""

### CLUMP FINDING 6

### Number to Pattern
def getVal(k):
    if k==0:
        return 'A'
    if k==1:
        return 'C'
    if k==2:
        return 'G'
    return 'T'
def NUMBERTOPATTERN(index, k):
    initial=index
    str=""
    while (k>0):
        rem=int(initial%4)
        str=str+getVal(rem)
        initial=initial/4
        k=k-1
    str=str[::-1]
    return str
 
###Clump Finding####
def SYMBOLTONUMBER(c):
    if c=='A':
        return 0
    if c=='C':
        return 1
    if c=='G':
        return 2
    if c=='T':
        return 3
 
def PATTERNTONUMBER(pattern):
    if len(pattern)==0:
        return 0 
    symbol=pattern[-1]
    prefix=pattern[0:len(pattern)-1]
    return 4*PATTERNTONUMBER(prefix)+SYMBOLTONUMBER(symbol)
 
def COMPUTINGFREQUENCIES(text, k):
    limit=(4**k)
    dic={};
    for i in range(limit):
        dic[i]=int(0)
    sz=len(text)-k+1
    for i in range(sz):
        pattern=text[i:i+k]
        #print("Pattern=",pattern)
        j=PATTERNTONUMBER(pattern)
        dic[j]=dic[j]+1
    return dic
 
genome="ACGTGCAT"
k=3
t=1
l=4
genomeSize=len(genome)
FrequentPatterns=set() #an empty set
#print(FrequentPatterns)
limit=(4**k)
CLUMP={}
for i in range(limit):
    CLUMP[i]=0
sz=genomeSize-l+1
for i in range(sz):
    txt=genome[i:i+l]
    #print("txt=",txt)
    FREQUENCYARRAY=COMPUTINGFREQUENCIES(txt,k)
    #print(FREQUENCYARRAY)
    for i in range(limit):
        if(FREQUENCYARRAY[i]>=t):
            CLUMP[i]=1
for i in range(limit):
    if CLUMP[i]==1:
        pattern=NUMBERTOPATTERN(i,k)
       # if pattern!=None:
        FrequentPatterns.add(pattern)
print(FrequentPatterns)

"""```
# This is formatted as code
```

***`Median String(not sure)`***
"""

#Median String 9
def decodeMedianString(s):
  l = len(s)
  s1 = "" 
  if(l % 2 == 0): 
        isEven = True
  else: 
        isEven = False
  for i in range(0, l, 2):
      if (isEven): 
            s1 = s[i] + s1 
            s1 += s[i + 1] 
      else : 
          if (l - i > 1):
            s1 += s[i] 
            s1 = s[i + 1] + s1 
          else: 
            s1 += s[i]
  return s1
if __name__ == '__main__': 
    s = "eetythkgs"
    print(decodeMedianString(s))



"""***`Frequence Word With mismatch`***"""

# Frequence Word With mismatch-7
wordstring = 'Here is a word string'
wordstring += ' Word String appends'
 
wordlist = wordstring.split()
 
wordfreq = []
for w in wordlist:
    wordfreq.append(wordlist.count(w))
 
print("String\n" + wordstring +"\n")
print("List\n" + str(wordlist) + "\n")
print("Frequencies\n" + str(wordfreq) + "\n")
print("Pairs\n" + str(list(zip(wordlist, wordfreq))))

"""***`Greedy MOtif Search`***"""

#Greedy Motif Search 10
def highest_probability(string, k, matrix):
    score = 1
    temp_string = ""
    c = 0
    best_string = ""
    temp = 0
    while c+k < len(string):
        for i in range(c, c+k):
            if string[i] == 'A':
                score *= matrix[i-c]['A']
                temp_string += 'A'
            elif string[i] == 'C':
                score *= matrix[i-c]['C']
                temp_string += 'C'
            elif string[i] == 'G':
                score *= matrix[i-c]['G']
                temp_string += 'G'
            elif string[i] == 'T':
                score *= matrix[i-c]['T']
                temp_string += 'T'
            if i == c+k-1:
                if score >= temp:
                    temp = score
                    best_string = temp_string
        temp_string=""
        score=1
        c+=1
    #print(best_string)
    return best_string
 
 
def GreedyMotifSearch(DNA, k, t):
    best_motifs = [i[0:k] for i in DNA]
    score=0
    c=0
    while c+k<len(DNA[0]):
        k_mer = DNA[0][c:c+k]
        motif=[k_mer]
        matrix = make_matrix(k_mer, matrix=[], i=0)
        for i in range(1, t):
            compare_string = DNA[i]
            good_motif = highest_probability(compare_string, k, matrix)
            motif.append(good_motif)
            matrix = make_matrix(good_motif, matrix, i)
        temp_score=1
        for dictionary in matrix:
            temp_score *= max(dictionary.values())
       # print(temp_score)
        if temp_score > score:
            score = temp_score
            best_motifs = motif
        c+=1
    return best_motifs
 
 
 
def make_matrix(string, matrix, i):
    if len(matrix)==0:
        for ch in string:
            new_dict = {'A':0, 'C':0, 'G':0, 'T':0}
            new_dict[ch] = 1
            matrix += [new_dict]
       # print(matrix)
        return matrix
    elif len(matrix)==3:
        for j in range(len(string)):
            matrix[j][string[j]] += 1
        Sum = [sum(matrix[0].values()),sum(matrix[1].values()),sum(matrix[2].values())]
        for columns in range(len(matrix)):
            for keys in matrix[columns]:
                matrix[columns][keys] /= Sum[columns]
        #print(matrix)
        return matrix 
 
DNA=['GGCGTTCAGGCA',
'AAGAATCAGTCA',
'CAAGGAGTTCGC',
'CACGTCAATCAC',
'CAATAATATTCG']
k=3
t=5
print(GreedyMotifSearch(DNA, k, t))

"""***`Approximate Pattern Count`***"""

Pattern = "GAGCGCTGG"
Text = "GAGCGCTGGGTTAACTCGCTACTTCCCGACGAGCGCTGTGGCGCAAATTGGCGATGAAACTGCAGAGAGAACTGGTCATCCAACTGAATTCTCCCCGCTATCGCATTTTGATGCGCGCCGCGTCGATT"
d = 3

def HammingDistance(p, q):
    d = 0
    for p, q in zip(p, q): # your code here
        if p!= q:
            d += 1
    return d

def ApproximatePatternMatching(Pattern, Text, d):
    positions = [] # initializing list of positions
    for i in range(len(Text) - len(Pattern)+1):
        # and using distance < d, rather than exact matching
        if HammingDistance(Pattern, Text[i:i+len(Pattern)]) < d:
            positions.append(i)
    return positions

print (ApproximatePatternMatching(Pattern, Text, d))